#!/usr/bin/env babel-node --harmony

import csp from 'js-csp';
import glob from 'glob';
import walk from '../walk.js';
import hashNode from '../hash_node.js';
import mergeResults from '../merge_results.js';
import filterResults from '../filter_results.js';
import { editor } from '../editor.js';
import { ui } from '../lib/assistant/ui.js'

function files(pattern) {
  const result = csp.chan();
  glob(pattern, function(err, files) {
    csp.operations.onto(result, files);
  });
  return result;
}

function print(chan) {
  csp.go(function*() {
    while (true) {
      let val = yield csp.take(chan);
      if (val === csp.CLOSED) {
        return;
      }
      console.log(val);
    }
  });
}

function traverse(chan) {
  var result = csp.chan(300000);
  csp.go(function*() {
    while (true) {
      let filename = yield csp.take(chan);
      if (filename === csp.CLOSED) {
        result.close();
        return;
      }
      let content = yield read(filename);
      var puts = [];
      walk(content, function(node) {
        puts.push(csp.go(function*() {
          node.file = filename;
          yield csp.put(result, node);
        }));
      });
      for (let put of puts) {
        yield put;
      }
    }
  });
  return result; 
}

function edit(file, lineNumber) {
  return function() {
    return editor(file, lineNumber);
  };
}

function detectInterpolationCandidates(nodesChan) {
  var result = csp.chan();
  csp.go(function*() {
    while (true) {
      var node = yield csp.take(nodesChan);
      if (node === csp.CLOSED) {
        result.close();
        return;
      }

      if ((node.parent && node.parent.type !== 'BinaryExpression') && node.type === 'BinaryExpression' && node.operator === '+' && (node.left.type === 'BinaryExpression' || (node.left.type === 'Literal' && typeof node.left.value === 'string'))) {
        var refactor = {
          name: 'interpolation-candidate',
          context: node.source(),
          options: {
            edit: edit(node.file, node.loc.start.line)
          }
        };
        yield csp.put(result, refactor);
      }
    }
  });
  return result;
}

function detectDuplications(nodesChan) {
  var resultChan = csp.chan();
  csp.go(function*() {
    const results = {};
    const hashes = {};
    while (true) {
      var node = yield csp.take(nodesChan);
      if (node === csp.CLOSED) {
        const mergableResults = Object.keys(results).map(function(filename) {
          return {file: filename, tree: results[filename]};
        })
        let duplications = filterResults(100, mergeResults(mergableResults));
        for (let duplicationHash in duplications) {
          let duplication = duplications[duplicationHash];
          let [file, lineNumber] = duplication.locations[0].split(':');
          var refactor = {
            name: 'duplication',
            context: duplication.source,
            options: {
              edit: edit(file, lineNumber)
            }
          };
          yield csp.put(resultChan, refactor);
        }
        resultChan.close();
        return;
      }

      var nodeSource = node.source();
      var result = hashNode(node.file, hashes, node);
      results[node.file] = results[node.file] || {};
      if (!results[node.file][result.hash]) {
        results[node.file][result.hash] = result;
        results[node.file][result.hash].file = node.file;
        results[node.file][result.hash].locations = [node.loc.start.line];
        results[node.file][result.hash].source = nodeSource;
      } else {
        results[node.file][result.hash].locations.push(node.loc.start.line);
        results[node.file][result.hash].source = nodeSource;
      }
    }
  });
  return resultChan;
}

function read(filename) {
  const result = csp.chan();
  require('fs').readFile(filename, function(err, buffer) {
    csp.go(function*() {
      yield csp.put(result, buffer.toString());
    });
  });
  return result;
}

var nodes = traverse(files(process.argv[2] || '*.js'));

var nodesMult = csp.operations.mult(nodes);

const detectors = [
  detectInterpolationCandidates,
  detectDuplications
];

const actions = csp.chan();

detectors.forEach(function(detector) {
  var detectorNodes = csp.chan();

  csp.operations.mult.tap(nodesMult, detectorNodes);

  csp.operations.pipe(detector(detectorNodes), actions, true);
});

ui(actions);
