#!/usr/bin/env babel-node --harmony

import csp from 'js-csp';
import glob from 'glob';
import walk from '../walk.js';
import hashNode from '../hash_node.js';
import mergeResults from '../merge_results.js';
import filterResults from '../filter_results.js';

function files() {
  const result = csp.chan();
  glob('*.js', function(err, files) {
    csp.operations.onto(result, files);
  });
  return result;
}

function print(chan) {
  csp.go(function*() {
    while (true) {
      let val = yield csp.take(chan);
      if (val === csp.CLOSED) {
        return;
      }
      console.log(val);
    }
  });
}

function traverse(chan) {
  var result = csp.chan();
  csp.go(function*() {
    while (true) {
      let filename = yield csp.take(chan);
      if (filename === csp.CLOSED) {
        result.close();
        return;
      }
      let content = yield read(filename);
      var puts = [];
      walk(content, function(node) {
        puts.push(csp.go(function*() {
          node.file = filename;
          yield csp.put(result, node);
        }));
      });
      for (let put of puts) {
        yield put;
      }
    }
  });
  return result; 
}

function detectInterpolationCandidates(nodesChan) {
  var result = csp.chan();
  csp.go(function*() {
    while (true) {
      var node = yield csp.take(nodesChan);
      if (node === csp.CLOSED) {
        result.close();
        return;
      }

      if ((node.parent && node.parent.type !== 'BinaryExpression') && node.type === 'BinaryExpression' && node.operator === '+' && (node.left.type === 'BinaryExpression' || (node.left.type === 'Literal' && typeof node.left.value === 'string'))) {
        yield csp.put(result, node.source());
      }
    }
  });
  return result;
}

function detectDuplications(nodesChan) {
  var resultChan = csp.chan();
  csp.go(function*() {
    const results = {};
    const hashes = {};
    while (true) {
      var node = yield csp.take(nodesChan);
      if (node === csp.CLOSED) {
        const mergableResults = Object.keys(results).map(function(filename) {
          return {file: filename, tree: results[filename]};
        })
        let duplications = filterResults(300, mergeResults(mergableResults));
        for (let duplicationHash in duplications) {
          yield csp.put(resultChan, duplications[duplicationHash]);
        }
        resultChan.close();
        return;
      }

      var nodeSource = node.source();
      var result = hashNode(node.file, hashes, node);
      results[node.file] = results[node.file] || {};
      if (!results[node.file][result.hash]) {
        results[node.file][result.hash] = result;
        results[node.file][result.hash].file = node.file;
        results[node.file][result.hash].locations = [node.loc.start.line];
        results[node.file][result.hash].source = nodeSource;
      } else {
        results[node.file][result.hash].locations.push(node.loc.start.line);
        results[node.file][result.hash].source = nodeSource;
      }
    }
  });
  return resultChan;
}

function read(filename) {
  const result = csp.chan();
  require('fs').readFile(filename, function(err, buffer) {
    csp.go(function*() {
      yield csp.put(result, buffer.toString());
    });
  });
  return result;
}

var nodes = traverse(files());

var nodesMult = csp.operations.mult(nodes);

const detectors = [
  detectInterpolationCandidates,
  detectDuplications
];

const actions = csp.chan();

detectors.forEach(function(detector) {
  var detectorNodes = csp.chan();

  csp.operations.mult.tap(nodesMult, detectorNodes);

  csp.operations.pipe(detector(detectorNodes), actions, true);
});

print(actions);
